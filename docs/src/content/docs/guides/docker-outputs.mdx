---
title: Docker Outputs
description: Learn how to cache and manage Docker images in your Grog build process for faster builds and deployments.
---

import { Aside } from "@astrojs/starlight/components";

## Introduction to Docker Caching

Many real-world CI/CD pipelines don't just produce files or directories but package entire applications into Docker images. Building Docker images can be time-consuming, especially for large applications, making them perfect candidates for caching.

Grog can cache Docker images, allowing you to:

- Skip rebuilding images when their inputs haven't changed
- Share images between team members using a remote cache
- Integrate Docker builds into your dependency graph
- Push images to registries only when needed

This guide covers how to set up Docker caching, configure storage backends, and define Docker outputs in your build targets.

## Setting Up Docker Caching

### 1. Enable Docker Support

First, add the following configuration to your `grog.toml` file at the root of your repository:

```toml
[docker]
enabled = true
```

### 2. Choose a Storage Backend

Grog supports two storage backends for Docker images:

#### Filesystem Backend (Default)

The filesystem backend stores Docker images as tarballs using your configured (remote) filesystem cache:

```toml
[docker]
enabled = true
backend = "tarball"  # This is the default, so it's optional
```

**Advantages:**

- Simple to set up
- Works with any filesystem cache
- No additional infrastructure required

**Disadvantages:**

- More storage-intensive as layers aren't deduplicated between images
- Slower for large images

#### Registry Backend

The registry backend stores Docker images in a Docker registry:

```toml
[docker]
enabled = true
backend = "registry"
registry_url = "https://your-registry-url"
```

**Advantages:**

- More efficient storage through layer deduplication
- Better performance for large images
- Familiar workflow for Docker users

**Disadvantages:**

- Requires a registry to be running and accessible
- Needs authentication setup

### 3. Registry Authentication

When using the registry backend, Grog expects your current session to be authenticated with the registry. Here's how to authenticate with common registries:

- **Docker Hub**: Use `docker login`
- **Google Artifact Registry**: Follow the [GCP authentication docs](https://cloud.google.com/artifact-registry/docs/docker/authentication)
- **AWS ECR**: Follow the [AWS ECR authentication docs](https://docs.aws.amazon.com/AmazonECR/latest/userguide/registry_auth.html)
- **GitHub Container Registry**: Use `docker login ghcr.io`

<Aside>
  For CI environments, you'll need to ensure authentication happens as part of
  your CI pipeline before Grog runs.
</Aside>

## Defining Docker Outputs

Once your Docker storage is set up, you can define Docker image outputs for your targets:

```yaml
targets:
  - name: build_api_image
    inputs:
      - Dockerfile
      - src/**/*.go
      - go.mod
      - go.sum
    command: |
      # Build the Docker image
      docker build -t api-service:latest .
    outputs:
      # Cache the local image
      - docker::api-service:latest
      # Also push to a registry (optional)
      - docker::registry.example.com/myteam/api-service:latest
```

### Docker Output Syntax

Docker outputs use the following syntax:

```
docker::[registry-url/][repository/]image-name[:tag]
```

- If a registry URL is included, Grog will push the image to that registry
- If no registry URL is included, Grog will only cache the image locally

### How Docker Caching Works

#### Local Images (without registry URL)

When you specify a Docker output without a registry URL:

```yaml
outputs:
  - docker::api-service:latest
```

- On build completion: Grog saves the local image to its cache
- On subsequent builds: Grog restores the image from cache to your local Docker daemon if inputs haven't changed
- Use this for images you need locally for testing or further builds

#### Registry Images (with registry URL)

When you specify a Docker output with a registry URL:

```yaml
outputs:
  - docker::registry.example.com/myteam/api-service:latest
```

- On build completion: Grog saves the image to its cache and pushes it to the specified registry
- On subsequent builds: Grog restores the image from cache and pushes it to the registry if inputs haven't changed
- Use this for images that need to be deployed or shared with others

## Using Docker Images in Dependent Targets

You can use Docker images built by one target in dependent targets:

```yaml
targets:
  - name: build_api_image
    inputs:
      - Dockerfile
      - src/**/*.go
    command: docker build -t api-service:latest .
    outputs:
      - docker::api-service:latest

  - name: integration_test
    dependencies:
      - :build_api_image
    command: |
      # The api-service image is now available locally
      docker run --rm api-service:latest --version
      # Run tests against the image
      go test -tags=integration ./tests/...
```

## Multi-platform Docker Images

For building multi-platform Docker images, see the [Multi-platform Builds](/guides/multi-platform-builds) guide.

## Best Practices

1. **Be specific with tags**: Use specific tags rather than `latest` to avoid confusion
2. **Include all inputs**: Make sure to list all files that affect your Docker build as inputs
3. **Use BuildKit**: Enable Docker BuildKit for faster, more efficient builds:
   ```yaml
   command: |
     DOCKER_BUILDKIT=1 docker build -t my-image:latest .
   ```
4. **Layer caching**: Structure your Dockerfiles to take advantage of layer caching
5. **Consider multi-stage builds**: Use multi-stage builds to keep final images small
6. **Registry selection**: For team environments, use a shared registry backend for better efficiency

## Troubleshooting

### Common Issues

#### "Error: docker not found"

Ensure Docker is installed and available in your PATH.

#### "Error pushing to registry"

Check your authentication status with:

```shell
docker login your-registry-url
```

#### "Error: image not found"

Make sure your Docker build command is creating an image with the exact tag specified in your outputs.

#### Slow Docker builds

Consider:

- Enabling BuildKit
- Using a `.dockerignore` file
- Optimizing your Dockerfile for better layer caching

<Aside type="tip">
  When debugging Docker caching issues, you can use `grog build --verbose` to
  see more details about what Grog is doing with Docker images.
</Aside>

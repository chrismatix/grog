---
title: Why Grog?
description: Learn what differentiates Grog from other build tools such as Bazel or Pants and when you should use it for your monorepo.
---

import graph from "../../assets/grog-stat.svg";

## The Monorepo Challenge

Many teams are recognizing the strong organizational value in moving to a monorepo ([see why](https://monorepo.tools/)).
Initially, teams might simply place all their projects in one repository.
However, as complexity grows and interdependencies emerge, challenges arise—especially when working with multiple languages or frameworks.

At this point, most teams are stuck between a rock and a hard place:

1. **Adopt sophisticated build tools** like Bazel or Pants, which require significant investment in learning and migration.
2. **Create ad-hoc solutions** with scripts, Makefiles, or internal CLIs, which often become maintenance burdens.

<img
  alt="Graph showing Grog's position between simple scripts and complex build systems, balancing ease of use with build optimization capabilities"
  height="800"
  src={graph.src}
  width="1200"
/>

## How Grog Helps

This is where **Grog** steps in—a tool designed to streamline your builds while allowing you to keep using the tools and commands you're already familiar with.

By focusing on efficiency and simplicity, Grog empowers your team to handle core build challenges without the overhead of larger tools. With Grog, you get:

1. **Dependency-aware execution** - Builds run in the correct order automatically, with simple dependency declarations.
2. **Parallel execution** - Run independent builds simultaneously for faster delivery.
3. **Incremental builds** - Rebuild only what's changed, saving valuable development time.

## Why choose Grog?

Most teams eventually reinvent these capabilities on their own—often through complex scripts that become difficult to maintain. Grog provides these essential features in one simple, cohesive system that's designed to grow with your needs.

Grog strikes the perfect balance between simplicity and power—giving you the benefits of optimized builds without forcing you to rewrite your entire build process.

## When _not_ to use Grog?

Grog might not be the right fit for you, if:

- You are using a single language stack that already has mature mono-repo build support (Java/Gradle, golang, JS, ...)
- You have higher demands for performance and reproducibility AND the spare engineering resources to adopt and maintain Bazel

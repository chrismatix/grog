syntax = "proto3";
package grog.proto.v1;

import "digest.proto";

option go_package = "grog/proto/gen";

message FileOutput {
  string path = 1; // Path relative to the target's package.
  Digest digest = 2;
  bool   is_executable = 3;
}

message DirectoryOutput {
  // Path relative to the target's package.
  string path = 1;

  // Digest of the serialized Tree proto in CAS.
  Digest tree_digest = 2;
}

enum ImageMode {
  LAYERS = 0;
  REGISTRY = 2;
}

message DockerImageOutput {
  // Where it's stored
  ImageMode mode = 1;
  // The tag under which to find the image locally when writing and where to
  // load it to when restoring
  string local_tag = 2;
  // digest of the tar file when stored in cas (tar mode)
  string tar_digest = 3;
  // this is the id return by docker inspect (registry mode)
  // the docs describe it as a content-addressable identifier
  string image_id = 4;
  // the remote tag for registry mode
  string remote_tag = 5;
  // Digest of the serialized manifest stored in CAS (filesystem backend).
  Digest manifest_digest = 6;
  // Digest of the config blob stored in CAS (filesystem backend).
  Digest config_digest = 7;
  // Digests of the image layers stored in CAS (filesystem backend).
  repeated Digest layer_digests = 8;
}

message Output {
  oneof kind {
    FileOutput file = 1;
    DirectoryOutput directory = 2;
    DockerImageOutput docker_image = 3;
  }
}

// A single target result cache entry.
// The change hash here is the key for retrieving it from the
message TargetResult {
  // The change hash of the action
  string change_hash = 1;
  // The combined digest of all of its outputs
  string output_hash = 2;

  // Declared outputs (files, dirs, docker images).
  repeated Output outputs = 3;

  int64 execution_duration_millis = 4;
}
